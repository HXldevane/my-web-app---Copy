{
  "version": 3,
  "sources": ["../../dubins-js/dist/index.mjs"],
  "sourcesContent": ["var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\n\n// src/util.ts\nfunction modulo(n1, n2) {\n  return (n1 % n2 + n2) % n2;\n}\n\n// src/index.ts\nvar SEGMENT_TYPES = {\n  LEFT: 1,\n  STRAIGHT: 2,\n  RIGHT: 3\n};\nvar PATH_TYPES = {\n  LSL: {\n    calc: function LSL(alpha, beta, d) {\n      let tmp0 = d + Math.sin(alpha) - Math.sin(beta);\n      let tmp1 = Math.atan2(Math.cos(beta) - Math.cos(alpha), tmp0);\n      let pSquared = 2 + d * d - 2 * Math.cos(alpha - beta) + 2 * d * (Math.sin(alpha) - Math.sin(beta));\n      if (pSquared < 0) {\n        return [-1, -1, -1];\n      } else {\n        return [\n          modulo(tmp1 - alpha, 2 * Math.PI),\n          Math.sqrt(pSquared),\n          modulo(beta - tmp1, 2 * Math.PI)\n        ];\n      }\n    },\n    segments: [SEGMENT_TYPES.LEFT, SEGMENT_TYPES.STRAIGHT, SEGMENT_TYPES.LEFT]\n  },\n  LSR: {\n    calc: function LSR(alpha, beta, d) {\n      let tmp0 = d + Math.sin(alpha) + Math.sin(beta);\n      let pSquared = -2 + d * d + 2 * Math.cos(alpha - beta) + 2 * d * (Math.sin(alpha) + Math.sin(beta));\n      if (pSquared < 0) {\n        return [-1, -1, -1];\n      } else {\n        let p = Math.sqrt(pSquared);\n        let tmp2 = Math.atan2(-1 * Math.cos(alpha) - Math.cos(beta), tmp0) - Math.atan2(-2, p);\n        let t = modulo(tmp2 - alpha, 2 * Math.PI);\n        let q = modulo(tmp2 - beta, 2 * Math.PI);\n        return [t, p, q];\n      }\n    },\n    segments: [SEGMENT_TYPES.LEFT, SEGMENT_TYPES.STRAIGHT, SEGMENT_TYPES.RIGHT]\n  },\n  RSL: {\n    calc: function RSL(alpha, beta, d) {\n      let tmp0 = d - Math.sin(alpha) - Math.sin(beta);\n      let pSquared = -2 + d * d + 2 * Math.cos(alpha - beta) - 2 * d * (Math.sin(alpha) + Math.sin(beta));\n      if (pSquared < 0) {\n        return [-1, -1, -1];\n      } else {\n        let p = Math.sqrt(pSquared);\n        let tmp2 = Math.atan2(Math.cos(alpha) + Math.cos(beta), tmp0) - Math.atan2(2, p);\n        let t = modulo(alpha - tmp2, 2 * Math.PI);\n        let q = modulo(beta - tmp2, 2 * Math.PI);\n        return [t, p, q];\n      }\n    },\n    segments: [SEGMENT_TYPES.RIGHT, SEGMENT_TYPES.STRAIGHT, SEGMENT_TYPES.LEFT]\n  },\n  RSR: {\n    calc: function RSR(alpha, beta, d) {\n      let tmp0 = d - Math.sin(alpha) + Math.sin(beta);\n      let tmp1 = Math.atan2(Math.cos(alpha) - Math.cos(beta), tmp0);\n      let pSquared = 2 + d * d - 2 * Math.cos(alpha - beta) + 2 * d * (Math.sin(beta) - Math.sin(alpha));\n      if (pSquared < 0) {\n        return [-1, -1, -1];\n      } else {\n        let t = modulo(alpha - tmp1, 2 * Math.PI);\n        let p = Math.sqrt(pSquared);\n        let q = modulo(-1 * beta + tmp1, 2 * Math.PI);\n        return [t, p, q];\n      }\n    },\n    segments: [SEGMENT_TYPES.RIGHT, SEGMENT_TYPES.STRAIGHT, SEGMENT_TYPES.RIGHT]\n  },\n  RLR: {\n    calc: function RLR(alpha, beta, d) {\n      let tmpRlr = (6 - d * d + 2 * Math.cos(alpha - beta) + 2 * d * (Math.sin(alpha) - Math.sin(beta))) / 8;\n      if (Math.abs(tmpRlr) > 1) {\n        return [-1, -1, -1];\n      } else {\n        let p = modulo(2 * Math.PI - Math.acos(tmpRlr), 2 * Math.PI);\n        let t = modulo(alpha - Math.atan2(Math.cos(alpha) - Math.cos(beta), d - Math.sin(alpha) + Math.sin(beta)) + modulo(p / 2, 2 * Math.PI), 2 * Math.PI);\n        let q = modulo(alpha - beta - t + modulo(p, 2 * Math.PI), 2 * Math.PI);\n        return [t, p, q];\n      }\n    },\n    segments: [SEGMENT_TYPES.RIGHT, SEGMENT_TYPES.LEFT, SEGMENT_TYPES.RIGHT]\n  },\n  LRL: {\n    calc: function LRL(alpha, beta, d) {\n      let tmpLrl = (6 - d * d + 2 * Math.cos(alpha - beta) + 2 * d * (-1 * Math.sin(alpha) + Math.sin(beta))) / 8;\n      if (Math.abs(tmpLrl) > 1) {\n        return [-1, -1, -1];\n      } else {\n        let p = modulo(2 * Math.PI - Math.acos(tmpLrl), 2 * Math.PI);\n        let t = modulo(-1 * alpha - Math.atan2(Math.cos(alpha) - Math.cos(beta), d + Math.sin(alpha) - Math.sin(beta)) + p / 2, 2 * Math.PI);\n        let q = modulo(modulo(beta, 2 * Math.PI) - alpha - t + modulo(p, 2 * Math.PI), 2 * Math.PI);\n        return [t, p, q];\n      }\n    },\n    segments: [SEGMENT_TYPES.LEFT, SEGMENT_TYPES.RIGHT, SEGMENT_TYPES.LEFT]\n  }\n};\nvar SEGMENT_ORDER = [\n  \"LSL\",\n  \"LSR\",\n  \"RSL\",\n  \"RSR\",\n  \"RLR\",\n  \"LRL\"\n];\nfunction map(num, inMin, inMax, outMin, outMax) {\n  return (num - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\nvar Dubins = class {\n  constructor(segments, turnRadius) {\n    this.segments = segments;\n    this.turnRadius = turnRadius;\n  }\n  curves(wpt1, wpt2, turnRadius) {\n    throw new Error(\"Untested! Please test this before allowing use in the API.\");\n    wpt1 = __spreadValues({}, wpt1);\n    wpt2 = __spreadValues({}, wpt2);\n    let tz = [0, 0, 0, 0, 0, 0];\n    let pz = [0, 0, 0, 0, 0, 0];\n    let qz = [0, 0, 0, 0, 0, 0];\n    let psi1 = wpt1.psi;\n    let psi2 = wpt2.psi;\n    let dx = wpt2.x - wpt1.x;\n    let dy = wpt2.y - wpt1.y;\n    let D = Math.sqrt(dx * dx + dy * dy);\n    let d = D / turnRadius;\n    let theta = modulo(Math.atan2(dy, dx), 2 * Math.PI);\n    let alpha = modulo(psi1 - theta, 2 * Math.PI);\n    let beta = modulo(psi2 - theta, 2 * Math.PI);\n    let bestWord = -1;\n    let bestCost = -1;\n    let orderedFns = SEGMENT_ORDER.map((key) => PATH_TYPES[key].calc);\n    for (let i = 0; i < orderedFns.length; i++) {\n      const [t, p, q] = orderedFns[i](alpha, beta, d);\n      tz[i] = t;\n      pz[i] = p;\n      qz[i] = q;\n    }\n    let curves = [];\n    for (let x = 0; x < 6; x++) {\n      if (tz[x] === -1) {\n        continue;\n      }\n      const segments = [];\n      let segmentStart = wpt1;\n      for (let i in PATH_TYPES[SEGMENT_ORDER[bestWord]].segments) {\n        let type = PATH_TYPES[SEGMENT_ORDER[bestWord]].segments[i];\n        let newSegment = new Segment(type, segmentStart, turnRadius, [tz, pz, qz][i][bestWord]);\n        segments.push(newSegment);\n        segmentStart = newSegment.absolutePointAt(newSegment.tprimeMax);\n      }\n      curves.push(new Dubins(segments, turnRadius));\n    }\n    return curves;\n  }\n  static path(wpt1, wpt2, turnRadius) {\n    let tz = [0, 0, 0, 0, 0, 0];\n    let pz = [0, 0, 0, 0, 0, 0];\n    let qz = [0, 0, 0, 0, 0, 0];\n    let psi1 = wpt1.psi;\n    let psi2 = wpt2.psi;\n    let dx = wpt2.x - wpt1.x;\n    let dy = wpt2.y - wpt1.y;\n    let D = Math.sqrt(dx * dx + dy * dy);\n    let d = D / turnRadius;\n    let theta = modulo(Math.atan2(dy, dx), 2 * Math.PI);\n    let alpha = modulo(psi1 - theta, 2 * Math.PI);\n    let beta = modulo(psi2 - theta, 2 * Math.PI);\n    let bestWord = -1;\n    let bestCost = -1;\n    let orderedFns = SEGMENT_ORDER.map((key) => PATH_TYPES[key].calc);\n    for (let i = 0; i < orderedFns.length; i++) {\n      const [t, p, q] = orderedFns[i](alpha, beta, d);\n      tz[i] = t;\n      pz[i] = p;\n      qz[i] = q;\n    }\n    let cost;\n    for (let x = 0; x < 6; x++) {\n      if (tz[x] != -1) {\n        cost = tz[x] + pz[x] + qz[x];\n        if (cost < bestCost || bestCost == -1) {\n          bestWord = x;\n          bestCost = cost;\n        }\n      }\n    }\n    const segments = [];\n    let segmentStart = wpt1;\n    for (let i in PATH_TYPES[SEGMENT_ORDER[bestWord]].segments) {\n      let type = PATH_TYPES[SEGMENT_ORDER[bestWord]].segments[i];\n      let newSegment = new Segment(type, segmentStart, turnRadius, [tz, pz, qz][i][bestWord]);\n      segments.push(newSegment);\n      segmentStart = newSegment.absolutePointAt(newSegment.tprimeMax);\n    }\n    return new Dubins(segments, turnRadius);\n  }\n  get tprimeMax() {\n    return this.segments[0].tprimeMax + this.segments[1].tprimeMax + this.segments[2].tprimeMax;\n  }\n  get length() {\n    return Math.floor(this.tprimeMax * this.turnRadius);\n  }\n  pointAt(pos) {\n    if (pos > 1) {\n      throw new Error(`Cannot get point at pos > 1 (${pos})`);\n    }\n    let tprime = map(pos, 0, 1, 0, this.tprimeMax);\n    if (tprime < this.segments[0].tprimeMax) {\n      return this.segments[0].absolutePointAt(tprime);\n    } else if (tprime - this.segments[0].tprimeMax < this.segments[1].tprimeMax) {\n      return this.segments[1].absolutePointAt(tprime - this.segments[0].tprimeMax);\n    } else {\n      return this.segments[2].absolutePointAt(tprime - this.segments[0].tprimeMax - this.segments[1].tprimeMax);\n    }\n  }\n  pointAtLength(length) {\n    if (length > this.length) {\n      throw new Error(\"length exceeds unit length\");\n    }\n    let tprime = length / this.turnRadius;\n    if (tprime < this.segments[0].tprimeMax) {\n      return this.segments[0].absolutePointAt(tprime);\n    } else if (tprime - this.segments[0].tprimeMax < this.segments[1].tprimeMax) {\n      return this.segments[1].absolutePointAt(tprime - this.segments[0].tprimeMax);\n    } else {\n      return this.segments[2].absolutePointAt(tprime - this.segments[0].tprimeMax - this.segments[1].tprimeMax);\n    }\n  }\n  toObject() {\n    return {\n      segments: this.segments.map((segment) => segment.toObject()),\n      turnRadius: this.turnRadius,\n      length: this.length,\n      tprimeMax: this.tprimeMax\n    };\n  }\n};\nvar Segment = class {\n  constructor(type, startPoint, turnRadius, tprimeMax) {\n    this.type = type;\n    this.startPoint = startPoint;\n    this.turnRadius = turnRadius;\n    this.tprimeMax = tprimeMax;\n  }\n  get length() {\n    return Math.floor(this.tprimeMax * this.turnRadius);\n  }\n  get center() {\n    let result = {\n      x: this.startPoint.x,\n      y: this.startPoint.y\n    };\n    if (this.type === SEGMENT_TYPES.STRAIGHT) {\n      let endPoint = this.absolutePointAt(this.tprimeMax);\n      result.x += endPoint.x;\n      result.x /= 2;\n      result.y += endPoint.y;\n      result.y /= 2;\n    } else {\n      let angleFromCenter = this.startPoint.psi + Math.PI / 2 * (this.type === SEGMENT_TYPES.LEFT ? -1 : 1);\n      result.x -= Math.cos(angleFromCenter) * this.turnRadius;\n      result.y -= Math.sin(angleFromCenter) * this.turnRadius;\n    }\n    return result;\n  }\n  get arcAngles() {\n    if (this.type === SEGMENT_TYPES.STRAIGHT)\n      return void 0;\n    let start = this.startPoint.psi + Math.PI / 2 * (this.type === SEGMENT_TYPES.LEFT ? -1 : 1);\n    let end = this.absolutePointAt(this.tprimeMax).psi + Math.PI / 2 * (this.type === SEGMENT_TYPES.LEFT ? -1 : 1);\n    return {\n      start,\n      end\n    };\n  }\n  pointAt(pos) {\n    if (pos > 1) {\n      throw new Error(`Cannot get point at pos > 1 (${pos})`);\n    }\n    let tprime = Math.min(map(pos, 0, 1, 0, this.tprimeMax), this.tprimeMax);\n    return this.absolutePointAt(tprime);\n  }\n  pointAtLength(length) {\n    if (length > this.length) {\n      throw new Error(\"length exceeds unit length\");\n    }\n    let tprime = Math.min(length / this.turnRadius, this.tprimeMax);\n    return this.absolutePointAt(tprime);\n  }\n  absolutePointAt(tprime) {\n    const point = {\n      x: 0,\n      y: 0,\n      psi: 0\n    };\n    if (this.type == SEGMENT_TYPES.LEFT) {\n      point.x = this.startPoint.x + (Math.sin(this.startPoint.psi + tprime) - Math.sin(this.startPoint.psi)) * this.turnRadius;\n      point.y = this.startPoint.y + (-Math.cos(this.startPoint.psi + tprime) + Math.cos(this.startPoint.psi)) * this.turnRadius;\n      point.psi = this.startPoint.psi + tprime;\n    } else if (this.type == SEGMENT_TYPES.RIGHT) {\n      point.x = this.startPoint.x + (-Math.sin(this.startPoint.psi - tprime) + Math.sin(this.startPoint.psi)) * this.turnRadius;\n      point.y = this.startPoint.y + (Math.cos(this.startPoint.psi - tprime) - Math.cos(this.startPoint.psi)) * this.turnRadius;\n      point.psi = this.startPoint.psi - tprime;\n    } else if (this.type == SEGMENT_TYPES.STRAIGHT) {\n      point.x = this.startPoint.x + Math.cos(this.startPoint.psi) * tprime * this.turnRadius;\n      point.y = this.startPoint.y + Math.sin(this.startPoint.psi) * tprime * this.turnRadius;\n      point.psi = this.startPoint.psi;\n    }\n    ;\n    point.psi = modulo(point.psi, 2 * Math.PI);\n    return point;\n  }\n  toObject() {\n    return {\n      type: this.type,\n      startPoint: this.startPoint,\n      turnRadius: this.turnRadius,\n      tprimeMax: this.tprimeMax,\n      length: this.length,\n      center: this.center,\n      arcAngles: this.arcAngles\n    };\n  }\n};\nexport {\n  Dubins,\n  SEGMENT_TYPES,\n  Segment\n};\n"],
  "mappings": ";AAAA,IAAI,YAAY,OAAO;AACvB,IAAI,sBAAsB,OAAO;AACjC,IAAI,eAAe,OAAO,UAAU;AACpC,IAAI,eAAe,OAAO,UAAU;AACpC,IAAI,kBAAkB,CAAC,KAAK,KAAK,UAAU,OAAO,MAAM,UAAU,KAAK,KAAK,EAAE,YAAY,MAAM,cAAc,MAAM,UAAU,MAAM,MAAM,CAAC,IAAI,IAAI,GAAG,IAAI;AAC1J,IAAI,iBAAiB,CAAC,GAAG,MAAM;AAC7B,WAAS,QAAQ,MAAM,IAAI,CAAC;AAC1B,QAAI,aAAa,KAAK,GAAG,IAAI;AAC3B,sBAAgB,GAAG,MAAM,EAAE,IAAI,CAAC;AACpC,MAAI;AACF,aAAS,QAAQ,oBAAoB,CAAC,GAAG;AACvC,UAAI,aAAa,KAAK,GAAG,IAAI;AAC3B,wBAAgB,GAAG,MAAM,EAAE,IAAI,CAAC;AAAA,IACpC;AACF,SAAO;AACT;AAGA,SAAS,OAAO,IAAI,IAAI;AACtB,UAAQ,KAAK,KAAK,MAAM;AAC1B;AAGA,IAAI,gBAAgB;AAAA,EAClB,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAO;AACT;AACA,IAAI,aAAa;AAAA,EACf,KAAK;AAAA,IACH,MAAM,SAAS,IAAI,OAAO,MAAM,GAAG;AACjC,UAAI,OAAO,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI;AAC9C,UAAI,OAAO,KAAK,MAAM,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,KAAK,GAAG,IAAI;AAC5D,UAAI,WAAW,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,QAAQ,IAAI,IAAI,IAAI,KAAK,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI;AAChG,UAAI,WAAW,GAAG;AAChB,eAAO,CAAC,IAAI,IAAI,EAAE;AAAA,MACpB,OAAO;AACL,eAAO;AAAA,UACL,OAAO,OAAO,OAAO,IAAI,KAAK,EAAE;AAAA,UAChC,KAAK,KAAK,QAAQ;AAAA,UAClB,OAAO,OAAO,MAAM,IAAI,KAAK,EAAE;AAAA,QACjC;AAAA,MACF;AAAA,IACF;AAAA,IACA,UAAU,CAAC,cAAc,MAAM,cAAc,UAAU,cAAc,IAAI;AAAA,EAC3E;AAAA,EACA,KAAK;AAAA,IACH,MAAM,SAAS,IAAI,OAAO,MAAM,GAAG;AACjC,UAAI,OAAO,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI;AAC9C,UAAI,WAAW,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,QAAQ,IAAI,IAAI,IAAI,KAAK,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI;AACjG,UAAI,WAAW,GAAG;AAChB,eAAO,CAAC,IAAI,IAAI,EAAE;AAAA,MACpB,OAAO;AACL,YAAI,IAAI,KAAK,KAAK,QAAQ;AAC1B,YAAI,OAAO,KAAK,MAAM,KAAK,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI,GAAG,IAAI,IAAI,KAAK,MAAM,IAAI,CAAC;AACrF,YAAI,IAAI,OAAO,OAAO,OAAO,IAAI,KAAK,EAAE;AACxC,YAAI,IAAI,OAAO,OAAO,MAAM,IAAI,KAAK,EAAE;AACvC,eAAO,CAAC,GAAG,GAAG,CAAC;AAAA,MACjB;AAAA,IACF;AAAA,IACA,UAAU,CAAC,cAAc,MAAM,cAAc,UAAU,cAAc,KAAK;AAAA,EAC5E;AAAA,EACA,KAAK;AAAA,IACH,MAAM,SAAS,IAAI,OAAO,MAAM,GAAG;AACjC,UAAI,OAAO,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI;AAC9C,UAAI,WAAW,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,QAAQ,IAAI,IAAI,IAAI,KAAK,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI;AACjG,UAAI,WAAW,GAAG;AAChB,eAAO,CAAC,IAAI,IAAI,EAAE;AAAA,MACpB,OAAO;AACL,YAAI,IAAI,KAAK,KAAK,QAAQ;AAC1B,YAAI,OAAO,KAAK,MAAM,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI,GAAG,IAAI,IAAI,KAAK,MAAM,GAAG,CAAC;AAC/E,YAAI,IAAI,OAAO,QAAQ,MAAM,IAAI,KAAK,EAAE;AACxC,YAAI,IAAI,OAAO,OAAO,MAAM,IAAI,KAAK,EAAE;AACvC,eAAO,CAAC,GAAG,GAAG,CAAC;AAAA,MACjB;AAAA,IACF;AAAA,IACA,UAAU,CAAC,cAAc,OAAO,cAAc,UAAU,cAAc,IAAI;AAAA,EAC5E;AAAA,EACA,KAAK;AAAA,IACH,MAAM,SAAS,IAAI,OAAO,MAAM,GAAG;AACjC,UAAI,OAAO,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI;AAC9C,UAAI,OAAO,KAAK,MAAM,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI,GAAG,IAAI;AAC5D,UAAI,WAAW,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,QAAQ,IAAI,IAAI,IAAI,KAAK,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,KAAK;AAChG,UAAI,WAAW,GAAG;AAChB,eAAO,CAAC,IAAI,IAAI,EAAE;AAAA,MACpB,OAAO;AACL,YAAI,IAAI,OAAO,QAAQ,MAAM,IAAI,KAAK,EAAE;AACxC,YAAI,IAAI,KAAK,KAAK,QAAQ;AAC1B,YAAI,IAAI,OAAO,KAAK,OAAO,MAAM,IAAI,KAAK,EAAE;AAC5C,eAAO,CAAC,GAAG,GAAG,CAAC;AAAA,MACjB;AAAA,IACF;AAAA,IACA,UAAU,CAAC,cAAc,OAAO,cAAc,UAAU,cAAc,KAAK;AAAA,EAC7E;AAAA,EACA,KAAK;AAAA,IACH,MAAM,SAAS,IAAI,OAAO,MAAM,GAAG;AACjC,UAAI,UAAU,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,QAAQ,IAAI,IAAI,IAAI,KAAK,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI,MAAM;AACrG,UAAI,KAAK,IAAI,MAAM,IAAI,GAAG;AACxB,eAAO,CAAC,IAAI,IAAI,EAAE;AAAA,MACpB,OAAO;AACL,YAAI,IAAI,OAAO,IAAI,KAAK,KAAK,KAAK,KAAK,MAAM,GAAG,IAAI,KAAK,EAAE;AAC3D,YAAI,IAAI,OAAO,QAAQ,KAAK,MAAM,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI,GAAG,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI,CAAC,IAAI,OAAO,IAAI,GAAG,IAAI,KAAK,EAAE,GAAG,IAAI,KAAK,EAAE;AACnJ,YAAI,IAAI,OAAO,QAAQ,OAAO,IAAI,OAAO,GAAG,IAAI,KAAK,EAAE,GAAG,IAAI,KAAK,EAAE;AACrE,eAAO,CAAC,GAAG,GAAG,CAAC;AAAA,MACjB;AAAA,IACF;AAAA,IACA,UAAU,CAAC,cAAc,OAAO,cAAc,MAAM,cAAc,KAAK;AAAA,EACzE;AAAA,EACA,KAAK;AAAA,IACH,MAAM,SAAS,IAAI,OAAO,MAAM,GAAG;AACjC,UAAI,UAAU,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,QAAQ,IAAI,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI,MAAM;AAC1G,UAAI,KAAK,IAAI,MAAM,IAAI,GAAG;AACxB,eAAO,CAAC,IAAI,IAAI,EAAE;AAAA,MACpB,OAAO;AACL,YAAI,IAAI,OAAO,IAAI,KAAK,KAAK,KAAK,KAAK,MAAM,GAAG,IAAI,KAAK,EAAE;AAC3D,YAAI,IAAI,OAAO,KAAK,QAAQ,KAAK,MAAM,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI,GAAG,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI,CAAC,IAAI,IAAI,GAAG,IAAI,KAAK,EAAE;AACnI,YAAI,IAAI,OAAO,OAAO,MAAM,IAAI,KAAK,EAAE,IAAI,QAAQ,IAAI,OAAO,GAAG,IAAI,KAAK,EAAE,GAAG,IAAI,KAAK,EAAE;AAC1F,eAAO,CAAC,GAAG,GAAG,CAAC;AAAA,MACjB;AAAA,IACF;AAAA,IACA,UAAU,CAAC,cAAc,MAAM,cAAc,OAAO,cAAc,IAAI;AAAA,EACxE;AACF;AACA,IAAI,gBAAgB;AAAA,EAClB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AACA,SAAS,IAAI,KAAK,OAAO,OAAO,QAAQ,QAAQ;AAC9C,UAAQ,MAAM,UAAU,SAAS,WAAW,QAAQ,SAAS;AAC/D;AACA,IAAI,SAAS,MAAM;AAAA,EACjB,YAAY,UAAU,YAAY;AAChC,SAAK,WAAW;AAChB,SAAK,aAAa;AAAA,EACpB;AAAA,EACA,OAAO,MAAM,MAAM,YAAY;AAC7B,UAAM,IAAI,MAAM,4DAA4D;AAC5E,WAAO,eAAe,CAAC,GAAG,IAAI;AAC9B,WAAO,eAAe,CAAC,GAAG,IAAI;AAC9B,QAAI,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAC1B,QAAI,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAC1B,QAAI,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAC1B,QAAI,OAAO,KAAK;AAChB,QAAI,OAAO,KAAK;AAChB,QAAI,KAAK,KAAK,IAAI,KAAK;AACvB,QAAI,KAAK,KAAK,IAAI,KAAK;AACvB,QAAI,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE;AACnC,QAAI,IAAI,IAAI;AACZ,QAAI,QAAQ,OAAO,KAAK,MAAM,IAAI,EAAE,GAAG,IAAI,KAAK,EAAE;AAClD,QAAI,QAAQ,OAAO,OAAO,OAAO,IAAI,KAAK,EAAE;AAC5C,QAAI,OAAO,OAAO,OAAO,OAAO,IAAI,KAAK,EAAE;AAC3C,QAAI,WAAW;AACf,QAAI,WAAW;AACf,QAAI,aAAa,cAAc,IAAI,CAAC,QAAQ,WAAW,GAAG,EAAE,IAAI;AAChE,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC1C,YAAM,CAAC,GAAG,GAAG,CAAC,IAAI,WAAW,CAAC,EAAE,OAAO,MAAM,CAAC;AAC9C,SAAG,CAAC,IAAI;AACR,SAAG,CAAC,IAAI;AACR,SAAG,CAAC,IAAI;AAAA,IACV;AACA,QAAI,SAAS,CAAC;AACd,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,UAAI,GAAG,CAAC,MAAM,IAAI;AAChB;AAAA,MACF;AACA,YAAM,WAAW,CAAC;AAClB,UAAI,eAAe;AACnB,eAAS,KAAK,WAAW,cAAc,QAAQ,CAAC,EAAE,UAAU;AAC1D,YAAI,OAAO,WAAW,cAAc,QAAQ,CAAC,EAAE,SAAS,CAAC;AACzD,YAAI,aAAa,IAAI,QAAQ,MAAM,cAAc,YAAY,CAAC,IAAI,IAAI,EAAE,EAAE,CAAC,EAAE,QAAQ,CAAC;AACtF,iBAAS,KAAK,UAAU;AACxB,uBAAe,WAAW,gBAAgB,WAAW,SAAS;AAAA,MAChE;AACA,aAAO,KAAK,IAAI,OAAO,UAAU,UAAU,CAAC;AAAA,IAC9C;AACA,WAAO;AAAA,EACT;AAAA,EACA,OAAO,KAAK,MAAM,MAAM,YAAY;AAClC,QAAI,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAC1B,QAAI,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAC1B,QAAI,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAC1B,QAAI,OAAO,KAAK;AAChB,QAAI,OAAO,KAAK;AAChB,QAAI,KAAK,KAAK,IAAI,KAAK;AACvB,QAAI,KAAK,KAAK,IAAI,KAAK;AACvB,QAAI,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE;AACnC,QAAI,IAAI,IAAI;AACZ,QAAI,QAAQ,OAAO,KAAK,MAAM,IAAI,EAAE,GAAG,IAAI,KAAK,EAAE;AAClD,QAAI,QAAQ,OAAO,OAAO,OAAO,IAAI,KAAK,EAAE;AAC5C,QAAI,OAAO,OAAO,OAAO,OAAO,IAAI,KAAK,EAAE;AAC3C,QAAI,WAAW;AACf,QAAI,WAAW;AACf,QAAI,aAAa,cAAc,IAAI,CAAC,QAAQ,WAAW,GAAG,EAAE,IAAI;AAChE,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC1C,YAAM,CAAC,GAAG,GAAG,CAAC,IAAI,WAAW,CAAC,EAAE,OAAO,MAAM,CAAC;AAC9C,SAAG,CAAC,IAAI;AACR,SAAG,CAAC,IAAI;AACR,SAAG,CAAC,IAAI;AAAA,IACV;AACA,QAAI;AACJ,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,UAAI,GAAG,CAAC,KAAK,IAAI;AACf,eAAO,GAAG,CAAC,IAAI,GAAG,CAAC,IAAI,GAAG,CAAC;AAC3B,YAAI,OAAO,YAAY,YAAY,IAAI;AACrC,qBAAW;AACX,qBAAW;AAAA,QACb;AAAA,MACF;AAAA,IACF;AACA,UAAM,WAAW,CAAC;AAClB,QAAI,eAAe;AACnB,aAAS,KAAK,WAAW,cAAc,QAAQ,CAAC,EAAE,UAAU;AAC1D,UAAI,OAAO,WAAW,cAAc,QAAQ,CAAC,EAAE,SAAS,CAAC;AACzD,UAAI,aAAa,IAAI,QAAQ,MAAM,cAAc,YAAY,CAAC,IAAI,IAAI,EAAE,EAAE,CAAC,EAAE,QAAQ,CAAC;AACtF,eAAS,KAAK,UAAU;AACxB,qBAAe,WAAW,gBAAgB,WAAW,SAAS;AAAA,IAChE;AACA,WAAO,IAAI,OAAO,UAAU,UAAU;AAAA,EACxC;AAAA,EACA,IAAI,YAAY;AACd,WAAO,KAAK,SAAS,CAAC,EAAE,YAAY,KAAK,SAAS,CAAC,EAAE,YAAY,KAAK,SAAS,CAAC,EAAE;AAAA,EACpF;AAAA,EACA,IAAI,SAAS;AACX,WAAO,KAAK,MAAM,KAAK,YAAY,KAAK,UAAU;AAAA,EACpD;AAAA,EACA,QAAQ,KAAK;AACX,QAAI,MAAM,GAAG;AACX,YAAM,IAAI,MAAM,gCAAgC,GAAG,GAAG;AAAA,IACxD;AACA,QAAI,SAAS,IAAI,KAAK,GAAG,GAAG,GAAG,KAAK,SAAS;AAC7C,QAAI,SAAS,KAAK,SAAS,CAAC,EAAE,WAAW;AACvC,aAAO,KAAK,SAAS,CAAC,EAAE,gBAAgB,MAAM;AAAA,IAChD,WAAW,SAAS,KAAK,SAAS,CAAC,EAAE,YAAY,KAAK,SAAS,CAAC,EAAE,WAAW;AAC3E,aAAO,KAAK,SAAS,CAAC,EAAE,gBAAgB,SAAS,KAAK,SAAS,CAAC,EAAE,SAAS;AAAA,IAC7E,OAAO;AACL,aAAO,KAAK,SAAS,CAAC,EAAE,gBAAgB,SAAS,KAAK,SAAS,CAAC,EAAE,YAAY,KAAK,SAAS,CAAC,EAAE,SAAS;AAAA,IAC1G;AAAA,EACF;AAAA,EACA,cAAc,QAAQ;AACpB,QAAI,SAAS,KAAK,QAAQ;AACxB,YAAM,IAAI,MAAM,4BAA4B;AAAA,IAC9C;AACA,QAAI,SAAS,SAAS,KAAK;AAC3B,QAAI,SAAS,KAAK,SAAS,CAAC,EAAE,WAAW;AACvC,aAAO,KAAK,SAAS,CAAC,EAAE,gBAAgB,MAAM;AAAA,IAChD,WAAW,SAAS,KAAK,SAAS,CAAC,EAAE,YAAY,KAAK,SAAS,CAAC,EAAE,WAAW;AAC3E,aAAO,KAAK,SAAS,CAAC,EAAE,gBAAgB,SAAS,KAAK,SAAS,CAAC,EAAE,SAAS;AAAA,IAC7E,OAAO;AACL,aAAO,KAAK,SAAS,CAAC,EAAE,gBAAgB,SAAS,KAAK,SAAS,CAAC,EAAE,YAAY,KAAK,SAAS,CAAC,EAAE,SAAS;AAAA,IAC1G;AAAA,EACF;AAAA,EACA,WAAW;AACT,WAAO;AAAA,MACL,UAAU,KAAK,SAAS,IAAI,CAAC,YAAY,QAAQ,SAAS,CAAC;AAAA,MAC3D,YAAY,KAAK;AAAA,MACjB,QAAQ,KAAK;AAAA,MACb,WAAW,KAAK;AAAA,IAClB;AAAA,EACF;AACF;AACA,IAAI,UAAU,MAAM;AAAA,EAClB,YAAY,MAAM,YAAY,YAAY,WAAW;AACnD,SAAK,OAAO;AACZ,SAAK,aAAa;AAClB,SAAK,aAAa;AAClB,SAAK,YAAY;AAAA,EACnB;AAAA,EACA,IAAI,SAAS;AACX,WAAO,KAAK,MAAM,KAAK,YAAY,KAAK,UAAU;AAAA,EACpD;AAAA,EACA,IAAI,SAAS;AACX,QAAI,SAAS;AAAA,MACX,GAAG,KAAK,WAAW;AAAA,MACnB,GAAG,KAAK,WAAW;AAAA,IACrB;AACA,QAAI,KAAK,SAAS,cAAc,UAAU;AACxC,UAAI,WAAW,KAAK,gBAAgB,KAAK,SAAS;AAClD,aAAO,KAAK,SAAS;AACrB,aAAO,KAAK;AACZ,aAAO,KAAK,SAAS;AACrB,aAAO,KAAK;AAAA,IACd,OAAO;AACL,UAAI,kBAAkB,KAAK,WAAW,MAAM,KAAK,KAAK,KAAK,KAAK,SAAS,cAAc,OAAO,KAAK;AACnG,aAAO,KAAK,KAAK,IAAI,eAAe,IAAI,KAAK;AAC7C,aAAO,KAAK,KAAK,IAAI,eAAe,IAAI,KAAK;AAAA,IAC/C;AACA,WAAO;AAAA,EACT;AAAA,EACA,IAAI,YAAY;AACd,QAAI,KAAK,SAAS,cAAc;AAC9B,aAAO;AACT,QAAI,QAAQ,KAAK,WAAW,MAAM,KAAK,KAAK,KAAK,KAAK,SAAS,cAAc,OAAO,KAAK;AACzF,QAAI,MAAM,KAAK,gBAAgB,KAAK,SAAS,EAAE,MAAM,KAAK,KAAK,KAAK,KAAK,SAAS,cAAc,OAAO,KAAK;AAC5G,WAAO;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EACA,QAAQ,KAAK;AACX,QAAI,MAAM,GAAG;AACX,YAAM,IAAI,MAAM,gCAAgC,GAAG,GAAG;AAAA,IACxD;AACA,QAAI,SAAS,KAAK,IAAI,IAAI,KAAK,GAAG,GAAG,GAAG,KAAK,SAAS,GAAG,KAAK,SAAS;AACvE,WAAO,KAAK,gBAAgB,MAAM;AAAA,EACpC;AAAA,EACA,cAAc,QAAQ;AACpB,QAAI,SAAS,KAAK,QAAQ;AACxB,YAAM,IAAI,MAAM,4BAA4B;AAAA,IAC9C;AACA,QAAI,SAAS,KAAK,IAAI,SAAS,KAAK,YAAY,KAAK,SAAS;AAC9D,WAAO,KAAK,gBAAgB,MAAM;AAAA,EACpC;AAAA,EACA,gBAAgB,QAAQ;AACtB,UAAM,QAAQ;AAAA,MACZ,GAAG;AAAA,MACH,GAAG;AAAA,MACH,KAAK;AAAA,IACP;AACA,QAAI,KAAK,QAAQ,cAAc,MAAM;AACnC,YAAM,IAAI,KAAK,WAAW,KAAK,KAAK,IAAI,KAAK,WAAW,MAAM,MAAM,IAAI,KAAK,IAAI,KAAK,WAAW,GAAG,KAAK,KAAK;AAC9G,YAAM,IAAI,KAAK,WAAW,KAAK,CAAC,KAAK,IAAI,KAAK,WAAW,MAAM,MAAM,IAAI,KAAK,IAAI,KAAK,WAAW,GAAG,KAAK,KAAK;AAC/G,YAAM,MAAM,KAAK,WAAW,MAAM;AAAA,IACpC,WAAW,KAAK,QAAQ,cAAc,OAAO;AAC3C,YAAM,IAAI,KAAK,WAAW,KAAK,CAAC,KAAK,IAAI,KAAK,WAAW,MAAM,MAAM,IAAI,KAAK,IAAI,KAAK,WAAW,GAAG,KAAK,KAAK;AAC/G,YAAM,IAAI,KAAK,WAAW,KAAK,KAAK,IAAI,KAAK,WAAW,MAAM,MAAM,IAAI,KAAK,IAAI,KAAK,WAAW,GAAG,KAAK,KAAK;AAC9G,YAAM,MAAM,KAAK,WAAW,MAAM;AAAA,IACpC,WAAW,KAAK,QAAQ,cAAc,UAAU;AAC9C,YAAM,IAAI,KAAK,WAAW,IAAI,KAAK,IAAI,KAAK,WAAW,GAAG,IAAI,SAAS,KAAK;AAC5E,YAAM,IAAI,KAAK,WAAW,IAAI,KAAK,IAAI,KAAK,WAAW,GAAG,IAAI,SAAS,KAAK;AAC5E,YAAM,MAAM,KAAK,WAAW;AAAA,IAC9B;AACA;AACA,UAAM,MAAM,OAAO,MAAM,KAAK,IAAI,KAAK,EAAE;AACzC,WAAO;AAAA,EACT;AAAA,EACA,WAAW;AACT,WAAO;AAAA,MACL,MAAM,KAAK;AAAA,MACX,YAAY,KAAK;AAAA,MACjB,YAAY,KAAK;AAAA,MACjB,WAAW,KAAK;AAAA,MAChB,QAAQ,KAAK;AAAA,MACb,QAAQ,KAAK;AAAA,MACb,WAAW,KAAK;AAAA,IAClB;AAAA,EACF;AACF;",
  "names": []
}
